(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{766:function(t,s,a){"use strict";a.r(s);var n=a(1),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"c-内存区域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#c-内存区域"}},[t._v("#")]),t._v(" C++内存区域")]),t._v(" "),a("p",[t._v("Created: March 17, 2024 2:51 PM")]),t._v(" "),a("p",[t._v("在C++中，内存主要被划分为几个区域，每个区域有其特定的用途、优势和区别。主要的内存区域包括：栈（Stack）、堆（Heap）、全局/静态存储区（Global/Static Storage）和代码区（Code Segment）。下面是各个区域的简介以及与之对应的代码示例。")]),t._v(" "),a("h3",{attrs:{id:"_1-栈-stack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-栈-stack"}},[t._v("#")]),t._v(" "),a("strong",[t._v("1. 栈（Stack）")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("用途")]),t._v("：主要用于存储局部变量和函数调用的上下文。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("生命周期")]),t._v("：自动管理，函数调用时分配，函数返回时释放。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("优势")]),t._v("：快速分配和释放，无需手动管理。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("示例代码")]),t._v("：")]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[t._v("cppCopy code\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" localVar "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 局部变量存储在栈上")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])])])]),t._v(" "),a("h3",{attrs:{id:"_2-堆-heap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-堆-heap"}},[t._v("#")]),t._v(" "),a("strong",[t._v("2. 堆（Heap）")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("用途")]),t._v("：用于动态内存分配，生命周期由程序员管理。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("生命周期")]),t._v("：使用**"),a("code",[t._v("new")]),a("strong",[t._v("分配，使用")]),a("code",[t._v("delete")]),t._v("**释放。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("优势")]),t._v("：灵活，能够动态分配大量内存。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("示例代码")]),t._v("：")]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[t._v("cppCopy code\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" dynamicArray "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在堆上动态分配内存")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("delete")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" dynamicArray"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 释放内存")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])])])]),t._v(" "),a("h3",{attrs:{id:"_3-全局-静态存储区-global-static-storage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-全局-静态存储区-global-static-storage"}},[t._v("#")]),t._v(" "),a("strong",[t._v("3. 全局/静态存储区（Global/Static Storage）")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("用途")]),t._v("：存储全局变量、静态变量和常量。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("生命周期")]),t._v("：程序启动时分配，程序结束时释放。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("优势")]),t._v("：在程序的整个生命周期内保持存在。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("示例代码")]),t._v("：")]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[t._v("cppCopy code\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" globalVar "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 全局变量")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" staticVar "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("30")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 静态局部变量")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])])])]),t._v(" "),a("h3",{attrs:{id:"_4-代码区-code-segment"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-代码区-code-segment"}},[t._v("#")]),t._v(" "),a("strong",[t._v("4. 代码区（Code Segment）")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("用途")]),t._v("：存储程序的机器代码。")]),t._v(" "),a("li",[a("strong",[t._v("生命周期")]),t._v("：程序启动时加载，程序结束时卸载。")]),t._v(" "),a("li",[a("strong",[t._v("优势")]),t._v("：存储编译后的程序代码，由操作系统管理。")]),t._v(" "),a("li",[a("strong",[t._v("示例代码")]),t._v("：代码区不直接通过C++代码操作，而是由编译后的程序决定。")])]),t._v(" "),a("h3",{attrs:{id:"区别和优势"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#区别和优势"}},[t._v("#")]),t._v(" "),a("strong",[t._v("区别和优势")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("栈")]),t._v("：快速且自动管理，适合存储生命周期短暂的变量。")]),t._v(" "),a("li",[a("strong",[t._v("堆")]),t._v("：灵活且能够动态分配大量内存，但需要手动管理，可能导致内存泄露或碎片化。")]),t._v(" "),a("li",[a("strong",[t._v("全局/静态存储区")]),t._v("：适用于存储在程序整个生命周期内需要保持的变量。")]),t._v(" "),a("li",[a("strong",[t._v("代码区")]),t._v("：存储程序执行代码，通常只读，保护程序代码不被意外修改。")])]),t._v(" "),a("p",[t._v("理解这些不同的内存区域及其特点有助于更好地管理内存使用和程序结构设计。")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("内存区域的大小——栈（Stack）、堆（Heap）、全局/静态存储区（Global/Static Storage）、和代码区（Code Segment）——主要取决于操作系统、系统的架构（32位或64位）、程序的编译方式以及系统对应用程序的配置。")]),t._v(" "),a("h3",{attrs:{id:"栈-stack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈-stack"}},[t._v("#")]),t._v(" "),a("strong",[t._v("栈（Stack）")])]),t._v(" "),a("ul",[a("li",[t._v("栈的大小是有限制的，通常由操作系统或运行时环境预设。在多数现代操作系统中，栈的大小对于每个线程通常在几百KB到几MB之间。例如，Windows的默认栈大小约为1MB，Linux在多数发行版中默认为8MB。栈溢出（当使用的栈空间超过了分配给栈的内存时发生）是常见的内存错误之一。")])]),t._v(" "),a("h3",{attrs:{id:"堆-heap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#堆-heap"}},[t._v("#")]),t._v(" "),a("strong",[t._v("堆（Heap）")])]),t._v(" "),a("ul",[a("li",[t._v("堆的大小理论上受限于虚拟内存的大小，即系统的物理内存加上硬盘上的交换空间（或分页文件）。这使得堆的大小可以非常大，远远超过栈的大小，理论上可以达到几GB甚至更多，具体取决于系统的物理内存大小和系统配置。")])]),t._v(" "),a("h3",{attrs:{id:"全局-静态存储区-global-static-storage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全局-静态存储区-global-static-storage"}},[t._v("#")]),t._v(" "),a("strong",[t._v("全局/静态存储区（Global/Static Storage）")])]),t._v(" "),a("ul",[a("li",[t._v("全局/静态存储区的大小通常是固定的，并且在编译时确定。它足够存储程序中所有的全局变量、静态变量和常量。这个区域的大小取决于程序的具体需求，但相比于栈和堆，它占用的内存量通常较小。")])]),t._v(" "),a("h3",{attrs:{id:"代码区-code-segment"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代码区-code-segment"}},[t._v("#")]),t._v(" "),a("strong",[t._v("代码区（Code Segment）")])]),t._v(" "),a("ul",[a("li",[t._v("代码区的大小直接对应于程序编译后的机器代码的大小。它在程序编译时被确定，并且在程序运行期间不会改变。代码区的大小取决于程序的复杂度和编译时的优化设置。")])]),t._v(" "),a("h3",{attrs:{id:"注意"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注意"}},[t._v("#")]),t._v(" "),a("strong",[t._v("注意")])]),t._v(" "),a("p",[t._v("这些区域的大小配置可以有很大的灵活性。例如，开发者可以在编译时或通过操作系统设置来调整栈的大小限制。同样，操作系统的配置和当前可用的系统资源也会影响堆的实际可用大小。")]),t._v(" "),a("p",[t._v("理解和合理配置这些内存区域的大小对于优化应用程序的性能和避免内存相关错误非常重要。例如，适当增加栈的大小可以避免栈溢出错误，而有效管理堆内存的使用可以减少内存泄露和碎片化的问题。")])])}),[],!1,null,null,null);s.default=e.exports}}]);