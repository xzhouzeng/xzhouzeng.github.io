(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{762:function(t,v,_){"use strict";_.r(v);var e=_(1),n=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"c-动态内存分配和静态的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#c-动态内存分配和静态的区别"}},[t._v("#")]),t._v(" C++动态内存分配和静态的区别")]),t._v(" "),_("p",[t._v("Created: March 17, 2024 1:26 PM")]),t._v(" "),_("p",[t._v("在C++中，例如**"),_("code",[t._v("int s[10];")]),_("strong",[t._v("和")]),_("code",[t._v("int* t = new int[10];")]),t._v("**这两行代码都创建了一个包含10个整数的数组，但它们在内存分配、生命周期和使用方式上有显著的区别。")]),t._v(" "),_("h3",{attrs:{id:"int-s-10"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#int-s-10"}},[t._v("#")]),t._v(" "),_("strong",[_("code",[t._v("int s[10];")])])]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("静态（或自动）内存分配")]),t._v("：这种方式在栈上分配内存。**"),_("code",[t._v("s")]),t._v("**是一个大小为10的整型数组，它的大小和生命周期都是在编译时确定的。")]),t._v(" "),_("li",[_("strong",[t._v("生命周期")]),t._v("：如果**"),_("code",[t._v("int s[10];")]),t._v("**在函数内部声明，它的生命周期限定在这个函数的执行期间。当函数返回时，这个数组会自动被销毁。")]),t._v(" "),_("li",[_("strong",[t._v("访问方式")]),t._v("：直接通过数组名和索引访问元素，例如**"),_("code",[t._v("s[0] = 100;")]),t._v("**。")])]),t._v(" "),_("h3",{attrs:{id:"int-t-new-int-10"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#int-t-new-int-10"}},[t._v("#")]),t._v(" "),_("strong",[_("code",[t._v("int* t = new int[10];")])])]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("动态内存分配")]),t._v("：这种方式在堆上分配内存，并返回指向这块内存首地址的指针。这行代码声明了一个指向整型的指针**"),_("code",[t._v("t")]),_("strong",[t._v("，并使用")]),_("code",[t._v("new")]),t._v("**操作符在堆上分配了一个包含10个整数的数组。")]),t._v(" "),_("li",[_("strong",[t._v("生命周期")]),t._v("：由程序员管理。这个数组会一直存在，直到使用**"),_("code",[t._v("delete[]")]),t._v("**操作符显式释放其内存。如果忘记释放，将导致内存泄漏。")]),t._v(" "),_("li",[_("strong",[t._v("访问方式")]),t._v("：通过指针访问数组元素，同样是使用索引，例如**"),_("code",[t._v("t[0] = 100;")]),t._v("**。")]),t._v(" "),_("li",[_("strong",[t._v("释放内存")]),t._v("：需要使用**"),_("code",[t._v("delete[] t;")]),t._v("**来释放分配的内存。")])]),t._v(" "),_("h3",{attrs:{id:"区别总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#区别总结"}},[t._v("#")]),t._v(" "),_("strong",[t._v("区别总结")])]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("内存分配位置")]),t._v("：**"),_("code",[t._v("int s[10];")]),_("strong",[t._v("在栈上分配内存，而")]),_("code",[t._v("int* t = new int[10];")]),t._v("**在堆上分配内存。")]),t._v(" "),_("li",[_("strong",[t._v("生命周期管理")]),t._v("：栈上分配的数组（"),_("strong",[_("code",[t._v("s")])]),t._v("）生命周期由编译器自动管理，而堆上分配的数组（"),_("strong",[_("code",[t._v("t")])]),t._v("）需要程序员手动管理。")]),t._v(" "),_("li",[_("strong",[t._v("性能考量")]),t._v("：栈上分配和回收速度通常比堆上分配快，但是堆上分配更灵活，能够处理更大的数据量或动态大小的数据。")])]),t._v(" "),_("p",[t._v("使用**"),_("code",[t._v("new")]),_("strong",[t._v("和")]),_("code",[t._v("delete")]),_("strong",[t._v("进行动态内存管理提供了更大的灵活性，但也带来了更大的责任，因为需要手动管理内存的生命周期，防止内存泄漏或其他相关问题。在现代C++编程中，通常推荐使用标准库中的容器，如")]),_("code",[t._v("std::vector<int>")]),t._v("**, 来代替裸数组和手动内存管理，以减少这种复杂性和潜在的错误。")])])}),[],!1,null,null,null);v.default=n.exports}}]);